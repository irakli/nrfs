# Network RAID Filesystem

## გაშვების ინსტრუქცია

საჭიროებს libssl ბიბლიოთეკას, კომპილაცია make საშუალებით.

---

### Data Structures

#### Client
```c
struct client_config_t
{
	char error_log[MAX_PATH_LENGTH];
	char cache_size[16];
	char cache_replacement[16];
	int timeout;
};

struct raid_storage_t
{
	int raid;
	char disk_name[MAX_NAME_LENGTH];
	char mount_point[MAX_PATH_LENGTH];
	char hot_swap[MAX_IP_LENGTH];
	vector servers;
};

struct server_t
{
	char *ip;
	int port;
};
```

#### Server
```c
struct server_config_t
{
	char mount_point[MAX_PATH_LENGTH];
	char ip[MAX_IP_LENGTH];
	int port;
};
```

#### Packets
```c
struct __attribute__((__packed__)) request_t
{
	enum syscalls syscall;
	char path[MAX_PATH_LENGTH];
	char new_path[MAX_PATH_LENGTH];
	int mask;
	mode_t mode;
	dev_t dev;
	off_t offset;
	size_t size;

	unsigned char digest[MD5_DIGEST_LENGTH];
	struct fuse_file_info fi;

	char ip[MAX_IP_LENGTH];
	int port;
};

struct __attribute__((__packed__)) response_t
{
	int status;
	char data[DATA_SIZE];

	char actual_hash[MD5_DIGEST_LENGTH * 2];
};

struct __attribute__((__packed__)) rw_response_t
{
	int status;
	size_t size;
};
```

### იმპლემენტირებულია მხოლოდ RAID 1

---

პროგრამის გაშვებისას, პირველად ხდება გადმოცემული კონფიგის დაპარსვა და მისი მონაცემების შენახვა. რადგან კონფიგში გადმოცემული სანახი სისტემების რაოდენობა წინასწარ განუსაზღვრელია, ამისთვის ვიყენებ ჩემსავე დაწერილ vector-ს, რომელსაც საკმარისზე მეტი ფუნქციონალი გააჩნია ამ ამოცანისთვის.

ამის შემდეგ ხდება RAID 1-ში არსებულ ორივე სერვერთან დაკავშირება. სოკეტებიდან პაკეტების ამოღება ხდება epoll-ის გამოყენებით, რაც ზრდის პროგრამის წარმადობას. სერვერსა და კლიენტს შორის კომუნიკაცია ხდება წინასწარ განსაზღვრული სტრუქტურების მიხედვით, რომელზე წვდომაც მათ საერთო header ფაილით აქვთ, რადგან syscall-ებს სულ რამოდენიმე არგუმენტი სჭირდებათ, ამისათვის ეს ყველა არგუმენტი გავაერთიანე ერთ სტრუქტურაში. ფიუზის მიერ გამოძახებული syscall კლიენტის მხარეს გაამზადებს ამ სტრუქუტრებს და შემდეგ ეს სტრუქტურა ქსელში გადაეგზავნება სერვერს.

`request_t` სტრუქტურის გადაცემა ხდება `raid_controller()` ფუნქციის საშუალებით, რომელიც ამოწმებს უზრუნველყოფს raid 1-ის სწორად მუშაობას, ეს ფუნქცია თავის მხრივ იძახებს `send_data()` ფუნქციას, რომელიც უშუალოდ ამყარებს სერვერებთან კავშირს. თუ syscall საჭიროებს buffer-ის გავსებას, მაშინ წინასწარ გადმოცემულ ზომას ელოდება `send_data()` და შესაბამის buffer-საც ავსებს.

`read` და `write` syscall-ებს გააჩნიათ საკუთარი `rw_raid_controller()` და `read_write()` ფუნქციები, რომლებიც იდეურად აკეთებს თითქმის იგივეს, რაც ზემოთ აღწერილი ფუნქციები, თუმცა ისინი მორგებულია უშუალოდ მონაცემების ჩაწერა/წაკითხვაზე, რაც ამარტივებს კოდს და მეტად უფრო გასაგებს ხდის.

`write`-ის გამოძახებისას მას ყველა ჯერზე ვაყოლებ შესაბამის ჰეშს, რომელიც შემდეგ სერვერზეც ლოკალურად მოწმდება და თუ ისინი ერთმანეთს არ დაემთხვა, მაშინ ვაბრუნებ შეცდომას. ეს უზრუნველყოფს, რომ ქსელში მონაცემები თუ დაზიანდა ამის შესახებ გავიგებთ და ნაგავი მონაცემები სერვერზე არავითარ შემთხვევაში არ აღმოჩნდება. მთლიანი ფაილის ჰეშის დათვლა ხდება ფაილის ჩაწერის დასრულების შემდეგ, როდესაც მოხდება `release`-ს გამოძახება, რაც გვანიშნებს ფაილის დასასრულს. ეს მიდგომა ბევრად მატებს პროგრამას წარმადობას, რადგან არ გვჭირდება ყოველ ჯერზე აქამდე მიღებული ფაილის ნაწილის ჰეშის გამოთვლა.

`write`-ის გამოძახება პარალელურად ხდება, რაც ბევრად აჩქარებს მონაცემების გაცვლას, ამითაც კვლავ ვიგებთ წარმადობას. რაც შეეხება `read`-ს, ის ხდება `main_server`-იდან, რომელიც თავდაპირველად არის მე-0 სერვერი კონფიგში, თუმცა პროგრამის მსვლელობისას შეიძლება შეიცვალოს, თუ ამ სერვერიდან წაკითხვა არ მოხერხდა, მაშინ იძახება სერვერის აღდგენის ფუნქცია, რომელზეც ქვემოთ ვისაუბრებ.

`open`-ის გამოძახების დროს მოწმდება სერვერებზე არსებული ფაილის და ამ ფაილზე extended attribute-ად ჩაწერილი ჰეშის შემოწმება და თუ რომელიმეზე ჰეში და ფაილის ნამდვილი ჰეშის დამთხვევა არ მოხდა, მაშინ იმ სერვერიდან, რომელზეც ესენი ემთხვევა, ხდება ფაილის გადაკოპირება.

ყველა syscall-ის გამოძახებისას ხდება შემოწმება იმისა, არის თუ არა ორივე სერვერი მწყობრში, თუ ერთ-ერთი გათიშულია, მაშინ ცალკე ნაკადში ხდება მასთან კონფიგში გადმოცემული დროის განმავლობაში კავშირის აღდგენა და თუ ეს ვერ მოხერხდა, მაშინ ავტომატურად ხდება swap სერვერის ჩართვა და მასზე მონაცემების გადატანა.

swap სერვერზე მონაცემების გადატანა ხდება ძალიან ჭკვიანური გზით [:-)], ხდება მუშა დირექტორიის tarball-ად გადაქცევა და მისი ქსელში ამ სახით გაგზავნა, რაც ბევრად ამარტივებს ამ პროცესს და თანაც ზოგავს ქსელში გასაგზავნი ბაიტების რაოდენობას, მითუმეტეს ლაპარაკი თუა ისეთ მონაცემებზე, როგორიცაა ტექსტური ფაილები. tar-ის გამო ასევე ნარჩუნდება extended attribute-ები, რის გამოც საჭირო აღარ არის მისი ცალკე გაგზავნა ან თავიდან დათვლა. რაც ასევე ბევრად აჩქარებს მთლიან პროცესს.

თუ წაკითხვისას მოხდა მთავარი სერვერის გათიშვა, მაშინ წაკითხვა გრძელდება სარეზერვო სერვერზე, მაგრამ თუ ამასობაში მთავარმა სერვერმა აღდგენა მოასწრო, წაკითხვა ისევ მასზე გადმოერთვება, ანუ დატვირთვა ამ მხრივ, როგორც წესი, მთავარ სერვერზე მოდის. მთავარი სერვერი იცვლება პროგრამის განმავლობაში იმის მიხედვით, მოხდება თუ არა swap, ფაილის აღდგენა და ა.შ.
